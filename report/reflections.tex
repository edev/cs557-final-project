\section{Final reflections}

For me, one of the biggest questions all term has been, ``How practical is Haskell in the real world?'' Although we had a guest speaker who uses Haskell in his professional work, I have found my own experience of redoing a real, in-the-wild project from another language to be particularly illuminating. In some ways, Yesod and thus Haskell shines. Persistent's DSL and auto-migrations are gleaming examples of Haskell's excellence! In other ways, Yesod and thus Haskell suffers by comparison. Persistent, for instance, entirely lacks Ruby on Rails' persistence abstractions that make working with live data nearly as fluid as working with a simple, in-memory object.

One of the primary lessons I've learned through this project is that features like pattern-matching and \code{Maybe} types replace lots of edge-case checks and provide significant (but not complete) compile-time correctness checks on these edge cases as well. This fundamentally different way of approaching program-writing fascinates me, though I'm not entirely sure which method I prefer.

Ruby was my favorite programming language for years, and it still scratches an itch that's hard to scratch these days: its beautifully designed metaprogramming facilities make it possible and even easy to write incredibly clean, elegant code (that, to my chagrin, can be horrendously hard to document or decipher under the hood). Template Haskell and QuasiQuoters, to my great surprise, fulfill similar roles in Haskell! And much of Ruby's power comes, in fact, from syntactic sugar over higher-order functions, first-class functions, and functional idioms like functors and maps. I didn't understand the powerful connection to functional programming until I took this course, and indeed, Yesod takes liberal advantage of both higher-order functions and metaprogramming, often with similarly hard-to-decipher generated code as a result! I will continue to consider Haskell and Ruby, side-by-side; I have not yet come to any conclusions about which I might prefer.

Yesod, in particular, does many things well. I hope I have commented on both the specific positive and negative experiences I have had with it thus far. I appreciate how it leverages Haskell's type checker in ways that are novel to me; it has helped me understand why Haskellers make such a big deal about the power of a type checker in the first place! Having said that, I have one gripe with Yesod in particular: it assumes an expert level of knowledge for everything. The learning curve is a steep cliff-climb followed by a smooth, gentle gradient beyond the clifftop. Even with my prior experience \emph{in the same problem domain}, plus many years of experience writing software, Yesod was intensely challenging to work with for the first 20 or 30 hours and then became almost second-nature after that.

In conclusion, I want to offer three criqitues that apply to my experiences of both Yesod and Haskell. In PSU's graduate operating systems class, one of the two-dozen research papers we read is called ``Experiences from a Decade of TinyOS Development'' \cite{tinyOS}. In this paper, the author makes three, pointed observations about TinyOS and the language nesC that co-evolved with it, and I feel these observations apply to Haskell and Yesod as well:

\begin{enumerate}
  \item By making it harder to write bugs, you also make it harder to write code!
  \item By changing things to make hard tasks possible, you tend to make easy tasks hard.
  \item By tailoring your language for expert users, you alienate newcomers and ultimately stifle your own language's growth.
\end{enumerate}
