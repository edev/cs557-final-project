\section{Storing pages in a database}

Now that we've covered most of the basics, we can look at adding new features to the scaffolded application. Given the stated scope and the time constraint of the project, our focus is on adding a narrow, vertical slice of features designed to let us learn about, experience, and discuss Haskell and Yesod. These features are \emph{not} designed to be production-ready but rather to fulfill these stated objectives. The first set of new features we add includes the ability to store pages in a database, associate them with URIs, and display them.

\subsection{Adding a table to the database}

Our first order of business is to learn enough about Persistent, Yesod's database abstraction layer \cite{ybkPersistent}, to create a new table. Persistent leverages Haskell data types to provide myriad type-safety guarantees going both to and from a backing store (in our case, SQLite). Persistent defines a sum type, \code{PersistValue}, whose constructors map to supported value types we can store in the database. The Yesod book defines \code{PersistValue} as follows \cite{ybkPersistent}:

\begin{Verbatim}
data PersistValue
    = PersistText Text
    | PersistByteString ByteString
    | PersistInt64 Int64
    | PersistDouble Double
    | PersistRational Rational
    | PersistBool Bool
    | PersistDay Day
    | PersistTimeOfDay TimeOfDay
    | PersistUTCTime UTCTime
    | PersistNull
    | PersistList [PersistValue]
    | PersistMap [(Text, PersistValue)]
    | PersistObjectId ByteString
    -- ^ Intended especially for MongoDB backend
    | PersistDbSpecific ByteString
    -- ^ Using 'PersistDbSpecific' allows you to use types
    -- specific to a particular backend
\end{Verbatim}

Meanwhile, columns are represented by the \code{PersistField} typeclass and tables are represented by the \code{PersistEntity} typeclass \cite{ybkPersistent}.

\paragraph{The models file} The scaffolded Yesod site reads its Persistent configuration from the file \code{config/models}, which defines the database configuration using a Persistent DSL \cite{ybkScaffolding}. The DSL features we utilize are as follows:

\begin{itemize}
  \item \term{Tables} are represented as top-level headers with no indentation. They should be CamelCased with initial capital.
  \item \term{Columns} are represented as lines indented under the table to which they belong. Three, space-separated fields make up a column declaration: 
  \begin{enumerate}
    \item The column name (camelCased with initial lowercase, for use as the name of a \code{PersistField}).
    \item The column type, as a \code{PersistValue} constructor type.
    \item Optionally, any additional attributes, such as \code{Maybe} to allow the column to be null.
  \end{enumerate}
  \item \term{Unique constraints} are represented at the same indentation level as columns, as follows:
  \begin{enumerate}
    \item The unique constraint name (CamelCased with initial capital).
    \item The names of any columns to be included in the constraint, space-separated.
    \item Optionally, the \code{force!} directive to allow a unique constraint involving a nullable column. (This is not allowed by default because Haskell and Yesod differ in their definitions of equality of null values \cite{ybkPersistent}.)
  \end{enumerate}
\end{itemize}

\paragraph{Defining a new table}

For the purposes of this project, we simply need one table that provides enough information to represent pages and, eventually, a single, unified navigation menu. Following the example of the real Sharing God's Bounty website, we represent a page as a title, a path (i.e. the relative path from the root of the site to the page), and some contents to be displayed in an article body. Meanwhile, to support menus, each page must be representable in the menu, which requires a numeric sorting order (so we can reorder pages) and a display text. The path and both menu-related fields should be nullable so that we can de-list a page completely if desired, making it entirely inaccessible to the public.

We complete our design with two unique constraints. First, no two pages should be allowed to have the same path, though this might be perfectly plausible under a different site architecture. Seecond, no two pages should be allowed to have the same numeric menu order.

These design specifications allow us to produce a full model in the Persistent DSL:

\begin{Verbatim}
BasicPage
    title Text                        -- The title of the page
    path Text Maybe                   -- The path to the page (nullable)
    menuOrder Int64 Maybe             -- The numeric order of the page in the menu (nullable)
    menuText Text Maybe               -- The text of the page's menu entry (nullable)
    content Text                      -- The page's body content
    UniquePath path !force            -- The path must be unique but may still be null
    UniqueMenuOrder menuOrder !force  -- The menu order must be unique but may still be null
\end{Verbatim}

\paragraph{Migrating the schema} For the uninitiated, database migrations are a standard notion of capturing changes to the database schema in a programmatic and reproducible way. In Ruby on Rails, we write migrations manually (or use a command-line utility to generate both our skeletal models and skeletal migrations). Yesod goes at least one step further: it automatically generates and runs migrations, when it's safe to do so, by comparing the Persistent schema to the database schema \cite{ybkPersistent}. Potentially destructive migrations must be written by hand. (We avoid them to narrow the scope of this project.) Thus, all that's required to create our table and teach Yesod how to handle it safely is to create the above specification in the Persistent DSL!

\paragraph{Reflections} Persistent is a bit of an odd duck. Then again, so is Ruby on Rails' ActiveRecord. I have taken issue with a number of Yesod's choices and limitations. Given that, I feel I need to highlight that my experience with Persistent has been stellar! This is the most remarkably helpful database DSL I have personally seen to date. It's cryptic at first, which is unsurprising in Yesod, but I am truly awe-struck by Persistent's expressive power!

Having said that, I take the same issue with Persistent that I take with ActiveRecord. Both DSLs attempt to solve the database problem space entirely in their host languages. In doing so, both DSLs take reductive views of databases that belie the power of a full-fledged DBMS. Both DSLs are well-suited to simple data stores like SQLite. As a SQL-literate developer, though, I prefer to take full advantage of a highly tuned, enormously powerful DBMS like Postgresql or Microsoft SQL Server. It is my personal opinion that when using a fully featured DBMS to its full advantage, a heavy-handed database abstraction layer simply gets in the way. Perhaps Persistent might work well in this use case with its migrations disabled (and without utilizing unique constraints), but I have my doubts. In either case, this particular query is well beyond the scope of this project.

\section{Adding a dynamic route}

In order to create a new route to receive requests for these database-backed pages, we first need to learn a bit more about Yesod's routing system. First, we'll discuss more advanced routes, and then we'll discuss the handlers that process them.

\subsubsection{Routing with PathPieces}

Yesod breaks routes into pieces, delimited by \code{/}, and parses them using data types that are instances of either the \code{PathPiece} or \code{PathMultiPiece} tyepclasses. It does so in a way that protects us from the details of parsing full routes and provides us with one, canonical URI for any given page \cite{ybkRouting}. There are three types of path pieces:

\begin{itemize}
  \item \term{Static text} must be matched exactly. The \code{/static} route discussed previously is static text.
  \item \term{Single pieces} are a single token (as defined by the \code{/} delimiters in the URI). We denote a single piece with the \code{\#} symbol followed by the name of a type that's an instance of the \code{PathPiece} type class.
  \item \term{Multi-pieces} can match any number of pieces. We denote multi-pieces with the \code{*} symbol followed by an instance of the \code{PathMultiPiece} typeclass. A multi-piece must be the last piece in a route.
\end{itemize}

\paragraph{Conversions} The \code{PathPiece} and \code{PathMultiPiece} typeclasses require us to define two-way conversions. \code{PathPiece} requires conversions between \code{Text} and the instance type. \code{PathMultiPiece} requires conversions beetween \code{[Text]} and the instance type. Converting from \code{Text} or \code{[Text]} returns a \code{Maybe} value, which allows us to guard against invalid input and guarantee that we're passing valid inputs into our route handlers. For instance, a multi-piece may enforce arbitrary constraints in its function \code{\frenchspacing fromPathMultiPiece :: PathMultiPiece s => [Text] -> Maybe s}; if it returns \code{Nothing}, the handler is never even invoked.

\paragraph{Ambiguous routes} By default, Yesod disallows routes that overlap and thus provide ambiguity. We can (and, in our case, must) override this behavior and explicitly allow certain routes to overlap by prefacing them with a \code{!} symbol. Yesod's rule when multiple routes match, which is common in routing systems, is that the first route wins \cite{ybkRouting}.

\subsubsection{Adding the route}

Our route itself is conceptually very simple: it will attempt to match any page that has not already matched a route against the known paths in our new database table. We'll use a multi-piece to allow pages to nest as needed, and we'll name our resource after the \code{BasicPath} table. Since only the \code{GET} HTTP method makes sense here, we will restrict our route to that method:

\begin{Verbatim}
!/*PagePath BasicPageR GET
\end{Verbatim}

The Yesod book does not precisely describe where to place our definition for \code{PagePath}'s membership in the \code{PathPiece} typeclass, but perhaps GHC can help us out. By running the application with the route (but without a handler or a definition for \code{instance PagePath PathPiece}), we can see where the definition is needed and make an educated guess about where it might belong. Sure enough, we see a helpful error (edited for clarity):

\begin{Verbatim}
[ 6 of 12] Compiling Foundation       ( src/Foundation.hs, ...)

src/Foundation.hs:68:1: error:
    Not in scope: type constructor or class ‘PagePath’
   |
68 | mkYesodData "App" $(parseRoutesFile "config/routes")
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

\end{Verbatim}

Following the Yesod book's example \cite{ybkRouting}, we define our own \code{PagePath} type and define its instantiation into \code{PathMultiPiece} (as well as a few base classes), and we place the definition at the bottom of \code{src/Foundation.hs}:

\begin{Verbatim}
-- Define the PagePath type needed for our BasicPageR route.
newtype PagePath = PagePath Text
  deriving (Eq, Show, Read)

-- Define converstions between PathPath and Text.
instance PathMultiPiece PagePath where
  -- toPathMultiPiece converts from a PagePath to [Text].
  -- The essential task here is to break a relative path such as
  --   "/foo/bar/baz"
  -- or
  --   "/foo/bar/baz/"
  -- to a list of tokens. In either case above, correct
  -- tokenization would be:
  --  ["foo", "bar", "baz"]
  --
  -- To do this, we'll unpack our Text to a String
  -- for pattern-matching, then use Data.Text.splitOn 
  -- to split our Text on '/' characters while safely
  -- ignoring a leading '/'. We'll take special care
  -- to handle the case of p="/", since T.splitOn
  -- will incorrectly yield ["", ""].
  toPathMultiPiece (PagePath p) = 
    case T.unpack p of
      [] -> []
      "/" -> []
      ('/':rest) -> T.splitOn "/" (T.pack rest)
      _ -> T.splitOn "/" p
        

  -- fromPathPiece converts from [Text] to a PagePath.
  -- We could query the database here to verify that
  -- the path exists, but that functionality is best
  -- left to the handler, for a variety of reasons.
  -- We simply need to join a list of Text objects
  -- with '/' characters, plus a leading '/' character.
  -- In the case of [], we want to produce the value "/"
  -- so that "/" can represent the homepage path in our
  -- DB, following the existing scheme.
  fromPathMultiPiece ts =
    case ts of
      [] -> Just (PagePath "/")
      _  -> Just (PagePath (concat $ map ("/" ++) ts))
\end{Verbatim}

\emph{Note: I assume there's a better way to handle overloaded strings than to unpack, pattern-match, and re-pack, but I had to learn about working with Text values on-the-fly, and I'm way over 32 hours on this project as-is. In terms of performance impact, this website gets 30 requests a day on an exceptionally busy day near Christmastime, so worrying about efficiency here would be a highly premature optimization.}

To verify that our links work correctly, we provide a temporary, initial handler that simply displays the parsed \code{PagePath} in the body of our templated page:

\begin{Verbatim}
getBasicPageR :: PagePath -> Handler Html
getBasicPageR (PagePath path) = defaultLayout $ do
      case path of
        "/" -> [whamlet|Home page: /|]
        _ -> [whamlet|Path: #{path}|]
\end{Verbatim}

Sure enough, visiting \code{localhost:3000} produces a beautiful Bounty webpage with the body text:

\begin{Verbatim}
Home page: /
\end{Verbatim}

And visiting \code{http://localhost:3000/abc/def} produces the body text:

\begin{Verbatim}
Path: /abc/def
\end{Verbatim}

Now we can add database interactivity as part of a real handler.

\subsection{Adding the handler}

Our route handler, in \code{src/Handler/BasicPage.hs}, is as follows:

\begin{Verbatim}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}

module Handler.BasicPage where

import Import

getBasicPageR :: PagePath -> Handler Html
getBasicPageR (PagePath pagePath) = do
      -- Try to retrieve the page from the database by looking up
      -- the path we received from the BasicPageR route.
      maybePage <- runDB $ getBy (UniquePath (Just pagePath))
      case maybePage of
        -- We received a valid page! Great!
        -- We'll unpack just what we need, discarding the rest,
        -- and render the layout by following the same basic steps
        -- as the default HomePageR handler.
        Just (Entity _ (BasicPage title _ _ _ content)) 
          -> defaultLayout $ do
                setTitle (toHtml title)
                $(widgetFile "basicpage")
        Nothing -> notFound -- No page with this path exists in the DB.
\end{Verbatim}

Let's talk about each part in a bit more detail.

First, we use the \code{getBy} function from Persistent to retrieve a page by its path. The \code{getBy} function accepts a unique constraint as its sole argument. From this argument, it infers the needed data types, the table to check, and the column(s) to check. (Ah, the power of the Haskell type system!) In loose terms, it takes variadic arguments: it accepts a unique constraint value, but that value's constructor may require arbitrary arguments. We wrap it in \code{runDB}, which is a convenience function the Yesod scaffolded site provides to pull from a pool of database connections.

Next, we unpack the \code{Maybe (Entity BasicPageId BasicPage)} value we received. If it's \code{Nothing}, the database had no matching row, so we simply use the \code{notFound} helper to terminate our handler with an appropriate response. If we did receive a matching row, then we unpack the fields we need (namely \code {title} and \code{content}), create a widget with those names in scope, and pass the widget into the \code{defaultLayout} renderer.

A \term{widget} is a key concept we skipped previously, but in very brief form, it's comprised of snippets of Hamlet, Lucius, Cassius, and/or Julius code, packed together in a format that Yesod is able to handle intelligently as a single unit. In our case, we just need an exceptionally simple \code{templates/basicpage.hamlet} file:

\begin{Verbatim}
<h1>#{title}
#{content}
\end{Verbatim}

This renders the body of any given page as a widget, using the values we unpacked from the database. When in the default template we invoke:

\begin{Verbatim}
^{widget}
\end{Verbatim}

Yesod renders this widget for us.

\emph{Note: I gloss over some minor details here, but to follow along, you'll need to add the new handler to the Cabal file and src/Foundation.hs, probably comment out your HomeR route (and lines that GHC warns you are unused once you remove that route), and tweak your scaffolded authentication. GHC will guide you, for the most part, as it guided me.}

